# LEEDARSON Sensor Management API

## Overview

You are part of the backend software development team responsible for creating a RESTful API to support operations for LEEDARSON. The backend application needs to expose endpoints to manage sensor information. Each sensor consists of the following attributes:
- `name` (String)
- `sensorTypeId` (Long)
- `description` (String)
- `manufacturer` (String)
- `referenceImageUrl` (String)

### Sensor Types
The sensors are classified by their `sensorType`. The available types are:
| Id           | Name       |
|------------------|-----------------|
| 1    | Temperature             |
| 2         | Motion      |
| 3        | Humidity     |

### Business Rules:
1. **Unique Combination:** The same combination of `name`, `sensorTypeId`, and `manufacturer` cannot be registered for more than one sensor.
2. **Valid Sensor Type:** The `sensorTypeId` must correspond to one of the valid types listed above.
3. **Pre-populated Sensor Types:** The `sensor_types` table should be pre-populated with sensor types. At the start of the application, there should be a check to populate the table if it is empty, using a command associated with an event handler triggered when the application is ready.
4. **Sensor Information:** The data to be persisted for each sensor includes:
    - `id` (Long, mandatory, autogenerated primary key)
    - `name` (String, mandatory, non-empty, max 50 characters)
    - `sensorTypeId` (Long, mandatory, non-empty)
    - `description` (String, mandatory, non-empty, max 360 characters)
    - `manufacturer` (String, mandatory, non-empty, max 100 characters)
    - `referenceImageUrl` (String, mandatory)
5. **Aggregate Root:** The `Sensor` is an aggregate root and must be auditable to track creation and update dates.

## Task: Implement Sensor Endpoint (`/api/v1/sensors`)

### API Operation: Create Sensor (`POST /api/v1/sensors`)

- Implement the operation to add a sensor using the `POST` method.
- Sensor `id` is auto-generated when storing the information, and it should **not** be provided during the sensor creation.
- Upon successful addition, the API should return HTTP Status `201` with the resource containing the sensor information and the generated `id`.
- If an error occurs, return the appropriate HTTP Status with the error message in the response body.

### Constraints:
1. **Java Version:** Java 22
2. **Framework:** Spring Boot 3
3. **ORM:** Spring Data JPA
4. **Database:** MySQL (Schema: `leedarson`)
5. **Package Structure:** `com.leedarson.platform.u<código-estudiante>` (e.g., `com.leedarson.platform.u201621873`)
6. **Bounded Context:** `devices`
7. **Best Practices:**
    - Apply Domain-Driven Design (DDD) principles.
    - Follow layered architecture (domain, application, interfaces, infrastructure).
    - Use the CQRS pattern where applicable.
    - Follow Java naming conventions (UpperCamelCase for classes, LowerCamelCase for variables and methods).
    - Database objects (tables) should use snake_case with plural names (no mnemonics).
8. **Shared Context:** Leverage reusable components in the `shared` bounded context.
9. **Documentation:**
    - Use JavaDoc for class and method documentation.
    - Include authorship information in JavaDoc (`@author`).
    - Add OpenAPI documentation with Swagger UI.
10. **API Endpoint Naming:** Use lowercase and plural for all URL endpoints.
11. **Listening Port:** The API should listen on port `8080`.

### Exception Handling
Implement proper exception handling within the application.

### Submission Instructions:
1. **Package the solution** as a `.zip` file with the following format:
    - `upc-pre202401-si729-<section>-pc2-u<código-estudiante>.zip` (e.g., `upc-pre-202401-si729-sw58-pc2-u201621873.zip`)
2. **Submit** the solution file as instructed for the graded practice activity.

### Exclusions:
1. CORS support.
2. Security configuration.
3. Unit or integration testing.
